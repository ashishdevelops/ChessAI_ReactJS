[{"/Users/ashish/Projects/chess_in_react/src/index.js":"1","/Users/ashish/Projects/chess_in_react/src/reportWebVitals.js":"2","/Users/ashish/Projects/chess_in_react/src/App.js":"3","/Users/ashish/Projects/chess_in_react/src/components/Board/Board.js":"4","/Users/ashish/Projects/chess_in_react/src/components/Piece/Piece.js":"5","/Users/ashish/Projects/chess_in_react/src/ChessAI.js":"6"},{"size":500,"mtime":1610048068948,"results":"7","hashOfConfig":"8"},{"size":362,"mtime":1610048068949,"results":"9","hashOfConfig":"8"},{"size":174,"mtime":1610152963880,"results":"10","hashOfConfig":"8"},{"size":8476,"mtime":1610695941576,"results":"11","hashOfConfig":"8"},{"size":3838,"mtime":1610693623147,"results":"12","hashOfConfig":"8"},{"size":8382,"mtime":1610603788267,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"4hk0kv",{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"27","usedDeprecatedRules":"16"},"/Users/ashish/Projects/chess_in_react/src/index.js",[],["28","29"],"/Users/ashish/Projects/chess_in_react/src/reportWebVitals.js",[],"/Users/ashish/Projects/chess_in_react/src/App.js",[],"/Users/ashish/Projects/chess_in_react/src/components/Board/Board.js",[],"/Users/ashish/Projects/chess_in_react/src/components/Piece/Piece.js",[],"/Users/ashish/Projects/chess_in_react/src/ChessAI.js",["30","31"],"var reverseArray = function(array) {\n    return array.slice().reverse();\n};\n\nvar pawnEvalWhite =\n    [\n        [0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0],\n        [5.0,  5.0,  5.0,  5.0,  5.0,  5.0,  5.0,  5.0],\n        [1.0,  1.0,  2.0,  3.0,  3.0,  2.0,  1.0,  1.0],\n        [0.5,  0.5,  1.0,  2.5,  2.5,  1.0,  0.5,  0.5],\n        [0.0,  0.0,  0.0,  2.0,  2.0,  0.0,  0.0,  0.0],\n        [0.5, -0.5, -1.0,  0.0,  0.0, -1.0, -0.5,  0.5],\n        [0.5,  1.0, 1.0,  -2.0, -2.0,  1.0,  1.0,  0.5],\n        [0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0]\n    ];\n\nvar pawnEvalBlack = reverseArray(pawnEvalWhite);\n\nvar knightEval =\n    [\n        [-5.0, -4.0, -3.0, -3.0, -3.0, -3.0, -4.0, -5.0],\n        [-4.0, -2.0,  0.0,  0.0,  0.0,  0.0, -2.0, -4.0],\n        [-3.0,  0.0,  1.0,  1.5,  1.5,  1.0,  0.0, -3.0],\n        [-3.0,  0.5,  1.5,  2.0,  2.0,  1.5,  0.5, -3.0],\n        [-3.0,  0.0,  1.5,  2.0,  2.0,  1.5,  0.0, -3.0],\n        [-3.0,  0.5,  1.0,  1.5,  1.5,  1.0,  0.5, -3.0],\n        [-4.0, -2.0,  0.0,  0.5,  0.5,  0.0, -2.0, -4.0],\n        [-5.0, -4.0, -3.0, -3.0, -3.0, -3.0, -4.0, -5.0]\n    ];\n\nvar bishopEvalWhite = [\n    [ -2.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -2.0],\n    [ -1.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, -1.0],\n    [ -1.0,  0.0,  0.5,  1.0,  1.0,  0.5,  0.0, -1.0],\n    [ -1.0,  0.5,  0.5,  1.0,  1.0,  0.5,  0.5, -1.0],\n    [ -1.0,  0.0,  1.0,  1.0,  1.0,  1.0,  0.0, -1.0],\n    [ -1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0, -1.0],\n    [ -1.0,  0.5,  0.0,  0.0,  0.0,  0.0,  0.5, -1.0],\n    [ -2.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -2.0]\n];\n\nvar bishopEvalBlack = reverseArray(bishopEvalWhite);\n\nvar rookEvalWhite = [\n    [  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0],\n    [  0.5,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  0.5],\n    [ -0.5,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, -0.5],\n    [ -0.5,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, -0.5],\n    [ -0.5,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, -0.5],\n    [ -0.5,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, -0.5],\n    [ -0.5,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, -0.5],\n    [  0.0,   0.0, 0.0,  0.5,  0.5,  0.0,  0.0,  0.0]\n];\n\nvar rookEvalBlack = reverseArray(rookEvalWhite);\n\nvar evalQueen =\n    [\n    [ -2.0, -1.0, -1.0, -0.5, -0.5, -1.0, -1.0, -2.0],\n    [ -1.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, -1.0],\n    [ -1.0,  0.0,  0.5,  0.5,  0.5,  0.5,  0.0, -1.0],\n    [ -0.5,  0.0,  0.5,  0.5,  0.5,  0.5,  0.0, -0.5],\n    [  0.0,  0.0,  0.5,  0.5,  0.5,  0.5,  0.0, -0.5],\n    [ -1.0,  0.5,  0.5,  0.5,  0.5,  0.5,  0.0, -1.0],\n    [ -1.0,  0.0,  0.5,  0.0,  0.0,  0.0,  0.0, -1.0],\n    [ -2.0, -1.0, -1.0, -0.5, -0.5, -1.0, -1.0, -2.0]\n];\n\nvar kingEvalWhite = [\n\n    [ -3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0],\n    [ -3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0],\n    [ -3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0],\n    [ -3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0],\n    [ -2.0, -3.0, -3.0, -4.0, -4.0, -3.0, -3.0, -2.0],\n    [ -1.0, -2.0, -2.0, -2.0, -2.0, -2.0, -2.0, -1.0],\n    [  2.0,  2.0,  0.0,  0.0,  0.0,  0.0,  2.0,  2.0 ],\n    [  2.0,  3.0,  1.0,  0.0,  0.0,  1.0,  3.0,  2.0 ]\n];\n\nvar kingEvalBlack = reverseArray(kingEvalWhite);\n\n\nclass ChessAI {\n    constructor(chess_game){\n        this.game = chess_game;\n        //this.board = chess_game.board();\n    }\n\n    move(depth, maximizingPlayer){\n        console.log('thinking')\n        let moves_list = this.game.moves({ verbose: true });\n        let best_move_value = -9999;\n        let best_move;\n\n        for(let i = 0; i < moves_list.length; i++) {\n            let some_move = moves_list[i];\n            this.game.move(some_move);\n            var value = this.minimax(depth, -10000, 10000, maximizingPlayer);\n            //var value = this.pvs(depth, Number.MIN_VALUE, Number.MAX_VALUE, -1);\n            this.game.undo();\n            if(value >= best_move_value){\n                best_move_value = value;\n                best_move = some_move;\n            }\n        }\n        console.log(\"AI MOVE\",best_move, best_move_value)\n\n        return {\n            piece: best_move['piece'],\n            from: best_move['from'].toUpperCase(),\n            to: best_move['to'].toUpperCase()\n        }\n    }\n\n    calculate_value(board){\n        let value = 0;\n        for(let i = 0; i < 8; ++i){\n            for(let j = 0; j < 8; ++j){\n                value = value + this.pieceValue(board[i][j],i,j);\n            }\n        }\n        return value;\n    }\n\n    pieceValue(piece, i, j){\n        let values = new Map([['k', 900],['q', 90],['r', 50],['b', 30],['n', 30],['p',10]])\n        let positions_black = new Map([['k', kingEvalBlack[i][j]],['q', evalQueen[i][j]],['r', rookEvalBlack[i][j]],['b', bishopEvalBlack[i][j]],['n', knightEval[i][j]],['p',pawnEvalBlack[i][j]]])\n        let positions_white = new Map([['k', kingEvalWhite[i][j]],['q', evalQueen[i][j]],['r', rookEvalWhite[i][j]],['b', bishopEvalWhite[i][j]],['n', knightEval[i][j]],['p',pawnEvalWhite[i][j]]])\n        if(piece){\n            if(piece.color === 'b'){\n                return -1*(values.get(piece.type)+positions_black.get(piece.type));\n            }else{\n                return values.get(piece.type)+positions_white.get(piece.type);\n            }\n        }\n        return 0;\n        // if (piece === null) {\n        //     return 0;\n        // }\n        // var getAbsoluteValue = function (piece, isWhite, x ,y) {\n        //     if (piece.type === 'p') {\n        //         return 10 + ( isWhite ? pawnEvalWhite[y][x] : pawnEvalBlack[y][x] );\n        //     } else if (piece.type === 'r') {\n        //         return 50 + ( isWhite ? rookEvalWhite[y][x] : rookEvalBlack[y][x] );\n        //     } else if (piece.type === 'n') {\n        //         return 30 + knightEval[y][x];\n        //     } else if (piece.type === 'b') {\n        //         return 30 + ( isWhite ? bishopEvalWhite[y][x] : bishopEvalBlack[y][x] );\n        //     } else if (piece.type === 'q') {\n        //         return 90 + evalQueen[y][x];\n        //     } else if (piece.type === 'k') {\n        //         return 900 + ( isWhite ? kingEvalWhite[y][x] : kingEvalBlack[y][x] );\n        //     }\n        //     throw \"Unknown piece type: \" + piece.type;\n        // };\n    \n        // var absoluteValue = getAbsoluteValue(piece, piece.color === 'w', x ,y);\n        // return piece.color === 'w' ? absoluteValue : -absoluteValue;\n    }\n\n    minimax(depth, alpha, beta, maximisingPlayer){\n\n        if (depth === 0) {\n            return -this.calculate_value(this.game.board());\n        }\n\n        var newGameMoves = this.game.moves({verbose : true});\n\n        if (maximisingPlayer) {\n            var bestMove = Number.MIN_VALUE;\n            for (let i = 0; i < newGameMoves.length; i++) {\n                this.game.move(newGameMoves[i]);\n                bestMove = Math.max(bestMove, this.minimax(depth - 1, alpha, beta, !maximisingPlayer));\n                this.game.undo();\n                alpha = Math.max(alpha, bestMove);\n                if (beta <= alpha) {\n                    return bestMove;\n                }\n            }\n            return bestMove;\n        } else {\n            var bestMove = Number.MAX_VALUE;\n            for (let i = 0; i < newGameMoves.length; i++) {\n                this.game.move(newGameMoves[i]);\n                bestMove = Math.min(bestMove, this.minimax(depth - 1, alpha, beta, !maximisingPlayer));\n                this.game.undo();\n                beta = Math.min(beta, bestMove);\n                if (beta <= alpha) {\n                    return bestMove;\n                }\n            }\n            return bestMove;\n        }\n    }\n\n    pvs(depth, alpha, beta, color){\n        if(depth === 0){\n            return color * this.calculate_value(this.game.board())\n        }\n\n        let moves_list = this.game.moves({verbose:true})\n\n        for(let i = 0; i < moves_list.length; ++i){\n            this.game.move(moves_list[i]);\n            if(i === 0){\n                var score = -this.pvs(depth-1,-beta,-alpha,-color);\n            }else{\n                var score = -this.pvs(depth-1,-alpha-1,-alpha,-color);\n                if(alpha < score && score < beta){\n                    score = -this.pvs(depth-1, -beta, -score, -color);\n                }\n            }\n            this.game.undo()\n            alpha = Math.max(alpha, score)\n            if(alpha >= beta){\n                break\n            }\n        }\n        return alpha\n    }\n}\n\nexport default ChessAI",{"ruleId":"32","replacedBy":"33"},{"ruleId":"34","replacedBy":"35"},{"ruleId":"36","severity":1,"message":"37","line":183,"column":17,"nodeType":"38","messageId":"39","endLine":183,"endColumn":25},{"ruleId":"36","severity":1,"message":"40","line":209,"column":21,"nodeType":"38","messageId":"39","endLine":209,"endColumn":26},"no-native-reassign",["41"],"no-negated-in-lhs",["42"],"no-redeclare","'bestMove' is already defined.","Identifier","redeclared","'score' is already defined.","no-global-assign","no-unsafe-negation"]